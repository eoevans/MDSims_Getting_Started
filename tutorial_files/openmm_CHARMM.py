# This script was generated by OpenMM-Setup on 2023-02-28.
# Hi Tyani. This script has a lot of things you will need to change if you want to use it. 
# Instead of having reading your parameters in, you need to just have them defined somewhere in the script itself
# It might be easier to copy and paste code from http://docs.openmm.org/latest/userguide/application/02_running_sims.html
# and the using CHARMM files section. Up to you. 

import sys
from openmm import *
from openmm.app import *
from simtk.unit import *
import time
import configparser
from params_validate import *
import os
from datetime import datetime

def get_cutoff_distance(dims):
    # args are box dimensions in A. Returns half the box distance in nm or 1.4 nm per Singer
    cutoff_distance = 1.4
    for i in dims:
        if i/20 < cutoff_distance:
            cutoff_distance = i/20
    return cutoff_distance*nanometers

if __name__ == '__main__':
    # start the clock
    start = time.time()

    # read in parameters. files and params are just dictionaries with the parameters that I am consistently changing
    files, params = get_files_params(sys.argv[1], 'openmm')

    # get correct surface_dims
    surface_dims = get_surface_dims(files['surface_details'])
    # box_dims is in nanometers
    box_dims = [params['x_len'], params['y_len'], surface_dims[2]+params['z_len']]

    # Input Files
    psf = CharmmPsfFile(files['psf_sim'])
    pdb = PDBFile(files['pdb_sim'])
    ff = CharmmParameterSet(files['rtf'], files['prm'], files['str'], 'MDSim/toppar/par_interface.prm', 'MDSim/toppar/top_interface.rtf')

    # System Configuration

    nonbondedMethod = PME
    constraints = None
    rigidWater = False

    # Integration Options

    dt = 0.001*picoseconds
    friction = 1.0/picosecond
    pressure = 1.0*atmospheres
    barostatInterval = 25

    # intdroduce boolean to turn GPU on or off
    if params['gpu']:
        platform = Platform.getPlatformByName('CUDA') #For CUDA, use 'CUDA'
        platformProperties = {'Precision': 'double'} #For CUDA, use 'Precision': 'double' or 'mixed' (for accuracy and speed, respectively.
    else:
        platform = Platform.getPlatformByName('CPU')
        platformProperties = {}
    # pdbReporter = PDBReporter(sys.argv[5], steps)
    dcd_interval = 100
    dcdReporter = DCDReporter(files['dcd'], dcd_interval)
    dataReporter = StateDataReporter(files['openmm_log'], 1000, totalSteps=params['equil_steps'],
        step=True, time=True, speed=True, progress=True, elapsedTime=True, remainingTime=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True, volume=True, density=True, separator='\t')

    # Prepare the Simulation

    print('Building system...')
    
    # set the box dimensions for periodic boundaries
    psf.setBox((params['x_len']/10)*nanometers, (params['y_len']/10)*nanometers, ((params['z_len']+surface_dims[2])/10)*nanometers)
    # create they system object
    system = psf.createSystem(ff, nonbondedMethod=nonbondedMethod,
                              nonbondedCutoff=get_cutoff_distance([params['x_len'],params['y_len'],params['z_len']]), 
                              constraints=constraints, rigidWater=rigidWater)
    # use a VerletIntegrator - this is supposed to give a constant Energy Density ensemble. See OpenMM User Guide
    integrator = VerletIntegrator(dt)
    # create simulation object
    simulation = Simulation(psf.topology, system, integrator)
    # set the initial positions using PDB
    simulation.context.setPositions(pdb.positions)


    # Minimize and Equilibrate

    print('Performing energy minimization...')
    simulation.minimizeEnergy()
    print('Equilibrating...')
    simulation.reporters.append(dataReporter)
    # use the temperature and maxwell boltzmann velocity distribution to set correct initial velocities 
    for i in range(int(params['equil_steps']/params['v_to_t_steps'])):
        simulation.step(params['v_to_t_steps'])
        simulation.context.setVelocitiesToTemperature(params['temp'])


    # Simulate
    print('Simulating...')
    simulation.reporters.append(dcdReporter)
    # simulation.reporters.append(pdbReporter)
    simulation.currentStep = 0
    simulation.step(params['sim_steps'])


    # end simulation section -- now to write the simulation parameters to the results file
    params['num_trajectory_frames'] = params['sim_steps']/dcd_interval
    params['run_time'] = params['sim_steps']*dt
    params['frame_spacing'] = params['run_time']/params['num_trajectory_frames']
    params['equil_time'] = params['equil_steps']*dt

    with open(files['results'], 'w') as f:
        f.write('Openmm\n')
        f.write('All temperatures are in Kelvin.\n')
        for key in params:
            f.write(key+' = '+str(params[key])+'\n')
        dt_string = datetime.now().strftime('%d/%m/%Y %H:%M:%S')
        f.write('appended on '+dt_string+'\n')
        f.write('script run time = '+time.strftime('%H:%M:%S', time.gmtime(time.time()-start))+'\n\n')
